"""Cross-language equivalence tests: Python vs Rust fixtures.

Verifies that the Python solver produces results matching the Rust solver
within numerical tolerance (f32 vs f64 divergence over iterations).

Fixtures are generated by `wasm/catune-solver/tests/generate_fixtures.rs`.
Run `cd wasm/catune-solver && cargo test generate_fixtures -- --ignored`
to regenerate.
"""

from __future__ import annotations

import json
from pathlib import Path

import numpy as np
import numpy.testing as npt
import pytest

from catune import build_kernel, run_deconvolution
from catune._fista import run_deconvolution_full
from catune._filter import bandpass_filter
from catune._io import deconvolve_from_export

FIXTURES_DIR = Path(__file__).parent / "fixtures"

# Collect all fixture files
FIXTURE_FILES = sorted(FIXTURES_DIR.glob("*.json"))
FIXTURE_NAMES = [f.stem for f in FIXTURE_FILES]


def load_fixture(name: str) -> dict:
    """Load a fixture JSON by name."""
    path = FIXTURES_DIR / f"{name}.json"
    with open(path) as f:
        return json.load(f)


# ---------------------------------------------------------------------------
# Parametrize over all fixtures
# ---------------------------------------------------------------------------

@pytest.fixture(params=FIXTURE_NAMES, ids=FIXTURE_NAMES)
def fixture(request) -> dict:
    return load_fixture(request.param)


# ---------------------------------------------------------------------------
# Test 1: Kernel matches Rust
# ---------------------------------------------------------------------------

@pytest.mark.parametrize("name", FIXTURE_NAMES)
def test_kernel_matches_rust(name: str):
    """Python build_kernel() cast to f32 matches Rust kernel within 1e-6."""
    data = load_fixture(name)
    params = data["params"]

    py_kernel = build_kernel(params["tau_rise"], params["tau_decay"], params["fs"])
    rust_kernel = np.array(data["kernel"], dtype=np.float32)

    # Python kernel is f64; cast to f32 for comparison
    py_kernel_f32 = py_kernel.astype(np.float32)

    npt.assert_allclose(
        py_kernel_f32[:len(rust_kernel)],
        rust_kernel,
        atol=1e-6,
        err_msg=f"Kernel mismatch for {name}",
    )


# ---------------------------------------------------------------------------
# Test 2: Solution matches Rust
# ---------------------------------------------------------------------------

@pytest.mark.parametrize("name", FIXTURE_NAMES)
def test_solution_matches_rust(name: str):
    """Python run_deconvolution() matches Rust solution within tolerance.

    Generous tolerance (atol=1e-2, rtol=1e-2) due to f32 vs f64 divergence
    over hundreds of FISTA iterations.
    """
    data = load_fixture(name)
    params = data["params"]

    # Use filtered trace if filter was applied
    if data["filter_enabled"] and data.get("filtered_trace"):
        trace = np.array(data["filtered_trace"], dtype=np.float64)
    else:
        trace = np.array(data["trace"], dtype=np.float64)

    rust_solution = np.array(data["solution"], dtype=np.float32)

    py_solution = run_deconvolution(
        trace,
        fs=params["fs"],
        tau_r=params["tau_rise"],
        tau_d=params["tau_decay"],
        lam=params["lambda"],
    )

    # Compare: generous tolerance for iterative f32/f64 divergence
    npt.assert_allclose(
        py_solution.astype(np.float32),
        rust_solution,
        atol=1e-2,
        rtol=1e-2,
        err_msg=f"Solution mismatch for {name}",
    )


# ---------------------------------------------------------------------------
# Test 3: Baseline matches Rust
# ---------------------------------------------------------------------------

@pytest.mark.parametrize("name", FIXTURE_NAMES)
def test_baseline_matches_rust(name: str):
    """Python baseline matches Rust within 0.5."""
    data = load_fixture(name)
    params = data["params"]

    if data["filter_enabled"] and data.get("filtered_trace"):
        trace = np.array(data["filtered_trace"], dtype=np.float64)
    else:
        trace = np.array(data["trace"], dtype=np.float64)

    rust_baseline = data["baseline"]

    result = run_deconvolution_full(
        trace,
        fs=params["fs"],
        tau_r=params["tau_rise"],
        tau_d=params["tau_decay"],
        lam=params["lambda"],
    )

    assert abs(result.baseline - rust_baseline) < 0.5, (
        f"Baseline mismatch for {name}: Python={result.baseline}, Rust={rust_baseline}"
    )


# ---------------------------------------------------------------------------
# Test 4: Filter matches Rust (with_filter fixture only)
# ---------------------------------------------------------------------------

def test_filter_matches_rust():
    """Python bandpass_filter() matches Rust filtered trace within 1e-3."""
    data = load_fixture("with_filter")
    params = data["params"]

    trace = np.array(data["trace"], dtype=np.float64)
    rust_filtered = np.array(data["filtered_trace"], dtype=np.float64)

    py_filtered = bandpass_filter(
        trace,
        tau_rise=params["tau_rise"],
        tau_decay=params["tau_decay"],
        fs=params["fs"],
    )

    npt.assert_allclose(
        py_filtered,
        rust_filtered,
        atol=1e-3,
        err_msg="Filter output mismatch vs Rust",
    )


# ---------------------------------------------------------------------------
# Test 5: Full pipeline from export JSON
# ---------------------------------------------------------------------------

@pytest.mark.parametrize("name", [n for n in FIXTURE_NAMES if n != "with_filter"])
def test_full_pipeline_from_export(name: str, tmp_path):
    """Create mock export JSON from fixture params, run deconvolve_from_export,
    compare to Rust solution."""
    data = load_fixture(name)
    params = data["params"]

    # Write mock export JSON
    export = {
        "schema_version": "1.1.0",
        "catune_version": "test",
        "export_date": "2025-01-01T00:00:00Z",
        "parameters": {
            "tau_rise_s": params["tau_rise"],
            "tau_decay_s": params["tau_decay"],
            "lambda": params["lambda"],
            "sampling_rate_hz": params["fs"],
            "filter_enabled": False,
        },
        "ar2_coefficients": {},
        "formulation": {},
        "metadata": {},
    }
    json_path = tmp_path / f"{name}_export.json"
    with open(json_path, "w") as f:
        json.dump(export, f)

    trace = np.array(data["trace"], dtype=np.float64)
    rust_solution = np.array(data["solution"], dtype=np.float32)

    py_solution = deconvolve_from_export(trace, json_path)

    npt.assert_allclose(
        py_solution.astype(np.float32),
        rust_solution,
        atol=1e-2,
        rtol=1e-2,
        err_msg=f"Pipeline mismatch for {name}",
    )

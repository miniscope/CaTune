---
phase: 05-multi-trace-and-export
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/ar2.ts
  - src/lib/export.ts
  - src/lib/viz-store.ts
  - src/components/traces/TracePanelStack.tsx
autonomous: true

must_haves:
  truths:
    - "User can pin current parameter results as a dimmed overlay for before/after comparison"
    - "Pinned snapshot is cleared when user switches cells to avoid stale cross-cell comparison"
    - "User can export parameters as JSON with AR2 coefficients, mathematical formulation, and metadata"
  artifacts:
    - path: "src/lib/ar2.ts"
      provides: "AR2 coefficient derivation from tau values (TypeScript port of Rust kernel.rs)"
      exports: ["computeAR2", "AR2Coefficients"]
    - path: "src/lib/export.ts"
      provides: "JSON export schema construction and Blob download trigger"
      exports: ["buildExportData", "downloadExport", "CaTuneExport"]
    - path: "src/lib/viz-store.ts"
      provides: "Pinned snapshot signals (pinnedDeconvolved, pinnedReconvolution, pinnedParams)"
      exports: ["pinnedDeconvolved", "pinnedReconvolution", "pinnedParams", "pinCurrentSnapshot", "unpinSnapshot"]
    - path: "src/components/traces/TracePanelStack.tsx"
      provides: "Pinned overlay series rendered as dimmed lines behind current fit"
      contains: "pinnedDeconvolved|pinnedReconvolution"
  key_links:
    - from: "src/lib/ar2.ts"
      to: "wasm/catune-solver/src/kernel.rs"
      via: "TypeScript port of tau_to_ar2 (same formula: d=exp(-dt/tau_decay), r=exp(-dt/tau_rise), g1=d+r, g2=-(d*r))"
      pattern: "Math\\.exp\\(-dt"
    - from: "src/lib/export.ts"
      to: "src/lib/ar2.ts"
      via: "calls computeAR2 to derive coefficients for export"
      pattern: "computeAR2"
    - from: "src/lib/export.ts"
      to: "src/lib/viz-store.ts"
      via: "reads tauRise, tauDecay, lambda for export payload"
      pattern: "tauRise\\(\\)|tauDecay\\(\\)|lambda\\(\\)"
    - from: "src/components/traces/TracePanelStack.tsx"
      to: "src/lib/viz-store.ts"
      via: "reads pinnedDeconvolved/pinnedReconvolution signals for overlay rendering"
      pattern: "pinnedDeconvolved|pinnedReconvolution"
---

<objective>
Add before/after snapshot comparison and parameter export with AR2 coefficients.

Purpose: Two independent features that together complete the parameter validation and export workflow. Before/after comparison lets users see if parameter changes improved the fit. Export produces a scientifically complete JSON file for downstream tools. Both features are foundational for Phase 7 (community DB) and Phase 8 (Python companion).

Output: AR2 derivation module, export schema/download module, pinned snapshot signals in viz-store, and pinned overlay rendering in TracePanelStack.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-trace-and-export/05-RESEARCH.md
@src/lib/viz-store.ts
@src/lib/data-store.ts
@src/lib/solver-types.ts
@src/components/traces/TracePanelStack.tsx
@wasm/catune-solver/src/kernel.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: AR2 coefficient derivation and JSON export with Blob download</name>
  <files>src/lib/ar2.ts, src/lib/export.ts</files>
  <action>
**src/lib/ar2.ts:**

Port the `tau_to_ar2` function from `wasm/catune-solver/src/kernel.rs` (lines 40-49) to TypeScript:

```typescript
export interface AR2Coefficients {
  g1: number;  // d + r (sum of AR2 roots)
  g2: number;  // -(d * r) (negative product of roots)
  d: number;   // exp(-dt/tau_decay) decay eigenvalue
  r: number;   // exp(-dt/tau_rise) rise eigenvalue
}

export function computeAR2(tauRise: number, tauDecay: number, fs: number): AR2Coefficients {
  const dt = 1 / fs;
  const d = Math.exp(-dt / tauDecay);
  const r = Math.exp(-dt / tauRise);
  return { g1: d + r, g2: -(d * r), d, r };
}
```

This is a direct port -- same formula, same variable names. Include a comment referencing the Rust source.

**src/lib/export.ts:**

Create the export schema and download function:

1. Define `CaTuneExport` interface matching the research schema:
   - `schema_version: string` (set to "1.0.0")
   - `catune_version: string` (read from package.json version or hardcode "0.0.1")
   - `export_date: string` (ISO 8601)
   - `parameters: { tau_rise_s, tau_decay_s, lambda, sampling_rate_hz }` (all numbers)
   - `ar2_coefficients: AR2Coefficients` (from computeAR2)
   - `formulation: { model, objective, kernel, ar2_relation, lambda_definition, convergence }` (all strings)
   - `metadata: { source_filename?: string, num_cells?: number, num_timepoints?: number }` (optional fields for Phase 7 forward compatibility)

2. `buildExportData(tauRise: number, tauDecay: number, lambda: number, fs: number, metadata?: { sourceFilename?: string, numCells?: number, numTimepoints?: number }): CaTuneExport`
   - Calls computeAR2 to derive coefficients
   - Populates all fields including the formulation strings:
     - model: "FISTA with adaptive restart and non-negativity constraint"
     - objective: "min_{s>=0} (1/2)||y - K*s||_2^2 + lambda*||s||_1"
     - kernel: "h(t) = exp(-t/tau_decay) - exp(-t/tau_rise), normalized to unit peak"
     - ar2_relation: "c[t] = g1*c[t-1] + g2*c[t-2] + s[t], where g1 = d+r, g2 = -(d*r), d = exp(-dt/tau_decay), r = exp(-dt/tau_rise)"
     - lambda_definition: "L1 penalty weight on spike train s in the FISTA objective function"
     - convergence: "Relative objective change < 1e-6 or max 2000 iterations"

3. `downloadExport(exportData: CaTuneExport, filename?: string): void`
   - Default filename: `catune-params-YYYY-MM-DD.json`
   - Use JSON.stringify with 2-space indentation
   - Create Blob with type 'application/json'
   - Create anchor element, set href to Object URL, set download attribute, click it
   - Append to document.body before click and remove after (Firefox compatibility)
   - Call URL.revokeObjectURL to prevent memory leak

Export CaTuneExport interface, buildExportData function, and downloadExport function.
  </action>
  <verify>
`npx tsc --noEmit` passes. `npx vitest run` passes. Verify AR2 math: for tauRise=0.02, tauDecay=0.4, fs=30, d=exp(-1/12)~0.9200, r=exp(-1/0.6)~0.1889, g1~1.1090, g2~-0.1738. These match the Rust test values.
  </verify>
  <done>
ar2.ts exports computeAR2 producing correct AR2 coefficients matching the Rust solver's kernel.rs implementation. export.ts exports buildExportData and downloadExport producing a scientifically complete JSON with schema_version for forward compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 2: Pinned snapshot signals and before/after overlay in TracePanelStack</name>
  <files>src/lib/viz-store.ts, src/components/traces/TracePanelStack.tsx</files>
  <action>
**src/lib/viz-store.ts additions:**

Add pinned snapshot signals BELOW the existing solver status section. Do NOT modify any existing signals or functions.

```typescript
// --- Pinned snapshot for before/after comparison ---
const [pinnedDeconvolved, setPinnedDeconvolved] = createSignal<Float64Array | null>(null);
const [pinnedReconvolution, setPinnedReconvolution] = createSignal<Float64Array | null>(null);
const [pinnedParams, setPinnedParams] = createSignal<{ tauRise: number; tauDecay: number; lambda: number } | null>(null);
```

Add action functions:

`pinCurrentSnapshot()`: copies current deconvolvedTrace and reconvolutionTrace into pinned signals (use `new Float64Array(...)` to deep copy). Also snapshot current tauRise/tauDecay/lambda into pinnedParams.

`unpinSnapshot()`: sets all three pinned signals to null.

Modify `loadCellTraces()`: add `unpinSnapshot()` call at the end -- this clears stale pinned data when the user switches cells, per research Pitfall 4.

Add all new signals and functions to the exports block.

**src/components/traces/TracePanelStack.tsx modifications:**

Import the new pinned signals from viz-store: pinnedDeconvolved, pinnedReconvolution.

Modify the `rawFitData` memo to include pinned overlay series when available:

- When pinnedReconvolution() is not null and has the same length as raw:
  - Downsample the pinned reconvolution using the same x buckets
  - Return [dsX, dsRawY, dsReconvY, dsPinnedReconvY] (4-series data)
- When null, return the existing 3-series data

Add a pinned reconvolution series config to rawFitSeries (conditionally):
- Label: "Pinned Fit"
- Stroke color: 'hsla(30, 90%, 60%, 0.35)' (same hue as fit but dimmed/semi-transparent)
- Width: 1.5
- Dash: [4, 4] (dashed line to visually distinguish from current fit)

Similarly for the deconvolved panel:
- When pinnedDeconvolved() is not null, add a second series to deconvolvedData
- Label: "Pinned Deconvolved"
- Stroke: 'hsla(120, 70%, 50%, 0.35)' (same hue as deconvolved but dimmed)
- Dash: [4, 4]

Use createMemo to derive the series configs reactively so they include or exclude the pinned series based on whether pinned data exists. This is important because uPlot needs the series array to match the data array length.

Do NOT add pinned overlay to the residuals panel (residuals are derived and would need separate computation -- keep it simple).
  </action>
  <verify>
`npx tsc --noEmit` passes. `npx vitest run` passes. `grep -n 'pinned' src/lib/viz-store.ts` shows pinned signals and action functions. `grep -n 'pinned' src/components/traces/TracePanelStack.tsx` shows pinned overlay integration. Verify unpinSnapshot is called in loadCellTraces.
  </verify>
  <done>
viz-store.ts has pinned snapshot signals with pin/unpin actions, and auto-clears pinned data on cell switch. TracePanelStack.tsx renders pinned deconvolved and reconvolution fit as dimmed dashed overlays when a snapshot is pinned, using reactive series configs that adapt to pinned state.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- all modified and new files type-check
2. `npx vitest run` -- no regressions
3. AR2 coefficients match Rust solver reference values
4. Pinned overlay appears as dimmed dashed series in raw+fit and deconvolved panels
5. Pinned snapshot clears on cell switch (loadCellTraces calls unpinSnapshot)
6. Export JSON includes schema_version, formulation strings, and AR2 coefficients
</verification>

<success_criteria>
- computeAR2 produces coefficients matching kernel.rs reference implementation
- buildExportData constructs complete CaTuneExport with forward-compatible schema
- downloadExport triggers browser file download of properly formatted JSON
- Pinned snapshot overlay renders as dimmed dashed lines behind current fit
- Pinned data auto-clears on cell switch to prevent stale comparison
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-trace-and-export/05-02-SUMMARY.md`
</output>

---
phase: 05-multi-trace-and-export
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/cell-ranking.ts
  - src/lib/multi-cell-store.ts
  - src/lib/multi-cell-solver.ts
autonomous: true

must_haves:
  truths:
    - "Cells can be ranked by activity level for top-N selection"
    - "User's cell selection mode (top-active, random, manual) determines which cells appear"
    - "Selected cells are solved sequentially through the existing worker without blocking interactive tuning"
  artifacts:
    - path: "src/lib/cell-ranking.ts"
      provides: "Cell activity ranking via variance, Fisher-Yates random sampling"
      exports: ["rankCellsByActivity", "sampleRandomCells"]
    - path: "src/lib/multi-cell-store.ts"
      provides: "Reactive state for cell selection mode, selected cells, display count, multi-cell results"
      exports: ["selectionMode", "selectedCells", "displayCount", "multiCellResults", "updateCellSelection"]
    - path: "src/lib/multi-cell-solver.ts"
      provides: "Batch solve selected cells via existing solver worker singleton"
      exports: ["solveSelectedCells"]
  key_links:
    - from: "src/lib/cell-ranking.ts"
      to: "data-store parsedData"
      via: "reads flat typed array with shape/swap info"
      pattern: "data\\.data\\["
    - from: "src/lib/multi-cell-store.ts"
      to: "src/lib/cell-ranking.ts"
      via: "calls rankCellsByActivity or sampleRandomCells based on selectionMode"
      pattern: "rankCellsByActivity|sampleRandomCells"
    - from: "src/lib/multi-cell-solver.ts"
      to: "src/workers/solver-api.ts"
      via: "calls createSolverWorker().solve() sequentially per cell"
      pattern: "createSolverWorker|worker\\.solve"
---

<objective>
Build the multi-cell data layer: cell activity ranking, reactive cell selection store, and batch multi-cell solver.

Purpose: Provides the data infrastructure for multi-trace validation. Users need to select interesting cells (top-N active, random sample, or manual pick) and see solver results for those cells -- this plan builds the non-UI logic that makes that possible.

Output: Three new modules (cell-ranking.ts, multi-cell-store.ts, multi-cell-solver.ts) providing reactive cell selection state and batch solving capability.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-trace-and-export/05-RESEARCH.md
@src/lib/data-store.ts
@src/lib/viz-store.ts
@src/lib/solver-types.ts
@src/workers/solver-api.ts
@src/lib/job-scheduler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cell activity ranking and random sampling utilities</name>
  <files>src/lib/cell-ranking.ts</files>
  <action>
Create src/lib/cell-ranking.ts with two pure functions:

1. `rankCellsByActivity(data: NpyResult, shape: [number, number], isSwapped: boolean): number[]`
   - Compute variance of each cell's raw trace as activity score (single-pass: track sum and sumSq, variance = sumSq/n - mean^2)
   - Access flat typed array using the same indexing pattern as viz-store.ts loadCellTraces(): if isSwapped, index = t * numCells + cellIndex; else index = cellIndex * numTimepoints + t
   - Sort cells by descending variance
   - Return array of cell indices sorted by activity (most active first)
   - Use Number() cast when reading from data.data (may be BigInt64Array for int64 dtypes, though unlikely for fluorescence data)

2. `sampleRandomCells(totalCells: number, n: number): number[]`
   - Fisher-Yates partial shuffle: only shuffle first min(n, totalCells) elements
   - Return array of n random cell indices (or all if n >= totalCells)
   - Uses Math.random() (no need for seeded PRNG here -- selection is a UI convenience, not scientific reproducibility)

Import NpyResult type from './types'. Export both functions as named exports.
  </action>
  <verify>
`npx vitest run` passes (no regressions). Manually verify the file exports the expected functions: `grep -n 'export function' src/lib/cell-ranking.ts` should show rankCellsByActivity and sampleRandomCells.
  </verify>
  <done>
rankCellsByActivity returns cell indices sorted by descending variance. sampleRandomCells returns n random cell indices via Fisher-Yates. Both compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Multi-cell reactive store and batch solver</name>
  <files>src/lib/multi-cell-store.ts, src/lib/multi-cell-solver.ts</files>
  <action>
**multi-cell-store.ts:**

Create reactive state for multi-cell selection and results using SolidJS signals (matching project pattern of module-level signals with named exports):

Signals:
- `selectionMode: SelectionMode` where `type SelectionMode = 'top-active' | 'random' | 'manual'` (default: 'top-active')
- `selectedCells: number[]` (default: [])
- `displayCount: number` (default: 5)
- `multiCellResults: Map<number, CellTraces>` (default: new Map())
- `multiCellSolving: boolean` (default: false) -- indicates batch solve in progress
- `multiCellProgress: { current: number; total: number } | null` (default: null)
- `activityRanking: number[] | null` (default: null) -- cached ranking, computed once on data load

Interface `CellTraces`:
```typescript
export interface CellTraces {
  cellIndex: number;
  raw: Float64Array;
  deconvolved: Float64Array;
  reconvolution: Float64Array;
}
```

Action function `computeAndCacheRanking()`: reads parsedData(), effectiveShape(), swapped() from data-store, calls rankCellsByActivity(), stores result in activityRanking signal. Call this once when data is loaded.

Action function `updateCellSelection()`: based on current selectionMode and displayCount:
- 'top-active': take first displayCount entries from activityRanking
- 'random': call sampleRandomCells(numCells, displayCount)
- 'manual': leave selectedCells unchanged (user controls directly)
Sets selectedCells signal.

Action function `clearMultiCellResults()`: resets multiCellResults to empty Map.

Export all signals (getters + setters), types, and action functions.

**multi-cell-solver.ts:**

Create `solveSelectedCells(cells: number[], params: SolverParams, data: NpyResult, shape: [number, number], isSwapped: boolean): Promise<Map<number, CellTraces>>`

Implementation:
- Import createSolverWorker from '../workers/solver-api'
- Import Comlink from 'comlink'
- Import setMultiCellSolving, setMultiCellProgress, setMultiCellResults from multi-cell-store
- Set multiCellSolving(true) and multiCellProgress({ current: 0, total: cells.length })
- For each cell in cells array (sequential loop with await):
  - Extract raw trace using same indexing as viz-store loadCellTraces (copy into new Float64Array)
  - Create a copy for transfer: `const traceCopy = new Float64Array(raw)`
  - Call `worker.solve(Comlink.transfer(traceCopy, [traceCopy.buffer]), { ...params }, null, 'cold', () => {})` -- cold start, no intermediate callback needed for batch
  - Copy results: `new Float64Array(result.solution)`, `new Float64Array(result.reconvolution)` to avoid detachment issues
  - Store in results Map as CellTraces
  - Update multiCellProgress({ current: i + 1, total: cells.length })
- Set multiCellSolving(false) and multiCellProgress(null)
- Set multiCellResults to the completed Map
- Return the Map

CRITICAL: The batch solver uses the same worker singleton as the interactive tuning loop. To prevent contention, the caller (App integration in Plan 03) must only invoke solveSelectedCells on parameter commit (onChange), NOT on slider drag (onInput). The solver processes one request at a time; the Comlink proxy serializes calls. This means if an interactive solve is in-flight when a batch starts, it will wait. This is acceptable because batch solves only trigger on commit (user released slider).

Handle errors with try/catch: if a cell fails, log the error and continue to the next cell (don't abort the entire batch).
  </action>
  <verify>
`npx tsc --noEmit` passes. `npx vitest run` passes (no regressions). Verify exports: `grep -n 'export' src/lib/multi-cell-store.ts src/lib/multi-cell-solver.ts` shows expected signals and functions.
  </verify>
  <done>
multi-cell-store.ts exports reactive signals for selection mode, selected cells, display count, results map, solving status, and progress. multi-cell-solver.ts exports solveSelectedCells that sequentially solves cells through the existing worker singleton. Both compile without errors and don't break existing functionality.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- all new files type-check
2. `npx vitest run` -- no regressions in existing tests
3. New modules export expected public API (signals, types, functions)
4. No modifications to existing files (pure additions)
</verification>

<success_criteria>
- cell-ranking.ts provides variance-based ranking and Fisher-Yates sampling
- multi-cell-store.ts provides reactive state for cell selection with three modes
- multi-cell-solver.ts provides batch solving through the existing worker singleton
- All modules follow project patterns (SolidJS signals, named exports, TypeScript)
- No new dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-trace-and-export/05-01-SUMMARY.md`
</output>
